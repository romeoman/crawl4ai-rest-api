---
description:
globs:
alwaysApply: false
---
# FastAPI Development Patterns

## **Lifespan Management**
- **Use asynccontextmanager for resource lifecycle**:
```python
@asynccontextmanager
async def lifespan(app: FastAPI) -> AsyncIterator[None]:
    # Initialize resources
    global app_context
    crawler = AsyncWebCrawler(config=browser_config)
    await crawler.__aenter__()
    app_context = AppContext(crawler=crawler)
    
    try:
        yield
    finally:
        # Clean up resources
        await crawler.__aexit__(None, None, None)
        app_context = None

app = FastAPI(lifespan=lifespan)
```

## **Request/Response Models**
- **Use Pydantic models for validation**:
```python
class CrawlSinglePageRequest(BaseModel):
    url: str
    force_recrawl: bool = False
    extraction_strategy: Optional[str] = None
    extraction_config: Optional[ExtractionConfig] = None

class CrawlSinglePageResponse(BaseModel):
    success: bool
    url: Optional[str] = None
    content_length: Optional[int] = None
    error: Optional[str] = None
```

## **Security and Authentication**
- **Bearer Token Authentication Pattern**:
```python
security = HTTPBearer(auto_error=False)

def get_api_key(credentials: HTTPAuthorizationCredentials = Security(security)):
    if credentials is None:
        if os.getenv("CRAWL4AI_API_KEY"):
            raise HTTPException(status_code=401, detail="Authorization header required")
        return None
    
    if not validate_api_key(credentials.credentials):
        raise HTTPException(status_code=401, detail="Invalid API key")
    
    return credentials.credentials
```

## **Error Handling Patterns**
- **Structured error responses**:
```python
try:
    # Operation logic
    return SuccessResponse(success=True, data=result)
except Exception as e:
    return ErrorResponse(success=False, error=str(e))
```

- **Global exception handling**:
```python
@app.exception_handler(Exception)
async def global_exception_handler(request: Request, exc: Exception):
    return JSONResponse(
        status_code=500,
        content={"success": False, "error": str(exc)}
    )
```

## **CORS Configuration**
- **Production-ready CORS setup**:
```python
app.add_middleware(
    CORSMiddleware,
    allow_origins=[
        "http://localhost:3000",  # React dev
        "http://localhost:5173",  # Vite dev
        "https://*.railway.app",  # Production
    ],
    allow_credentials=True,
    allow_methods=["GET", "POST", "PUT", "DELETE", "OPTIONS"],
    allow_headers=["Accept", "Content-Type", "Authorization"],
    max_age=86400,  # Cache preflight 24h
)
```

## **Dependency Injection**
- **Use FastAPI dependencies for shared resources**:
```python
def get_crawler():
    if not app_context:
        raise HTTPException(status_code=500, detail="Server not initialized")
    return app_context.crawler

@app.post("/crawl/single")
async def crawl_single_page(
    request: CrawlRequest,
    crawler: AsyncWebCrawler = Depends(get_crawler),
    api_key: str = Depends(get_api_key)
):
    # Endpoint logic
```

## **Background Tasks**
- **Use BackgroundTasks for async operations**:
```python
@app.post("/crawl/background")
async def crawl_background(
    request: CrawlRequest,
    background_tasks: BackgroundTasks,
    api_key: str = Depends(get_api_key)
):
    background_tasks.add_task(perform_crawl, request.url)
    return {"message": "Crawl started"}
```

## **Playground Interface Pattern**
- **Embedded HTML for testing interface**:
```python
@app.get("/playground")
async def playground(request: Request):
    html_content = """
    <!DOCTYPE html>
    <html>
    <head>
        <title>API Playground</title>
        <!-- Interactive forms and testing interface -->
    </head>
    <body>
        <!-- Dynamic endpoint testing -->
    </body>
    </html>
    """
    return HTMLResponse(content=html_content)
```

## **Response Model Consistency**
- **Consistent success/error format**:
```python
class BaseResponse(BaseModel):
    success: bool
    error: Optional[str] = None

class DataResponse(BaseResponse):
    data: Optional[Any] = None
    count: Optional[int] = None
```

## **Validation and Sanitization**
- **Input validation patterns**:
```python
class URLRequest(BaseModel):
    url: str = Field(..., regex=r'^https?://.+')
    
    @validator('url')
    def validate_url(cls, v):
        parsed = urlparse(v)
        if not parsed.netloc:
            raise ValueError('Invalid URL format')
        return v
```

## **Health and Monitoring**
- **Standard health check endpoint**:
```python
@app.get("/health")
async def health_check():
    return {
        "status": "healthy",
        "service": "Crawl4AI REST API",
        "timestamp": datetime.utcnow().isoformat()
    }
```

## **File References**
- Main API implementation: [rest_api.py](mdc:src/rest_api.py)
- Utility functions: [utils.py](mdc:src/utils.py)
- Testing guide: [POSTMAN_TESTING_GUIDE.md](mdc:POSTMAN_TESTING_GUIDE.md)
